class Solution {
public:
    const int mod = 1e9 + 7 ;
    int findPower(int b, int e) {
        if(e == 0) return 1 ;
        long long half = findPower(b, e/2) ;
        long long res = (half * half) % mod ;
        if(e % 2) res = (res * b) % mod ;
        return res ;
    }
    int modularnCr(int n, int r, vector<long long>& fact) {
        if(r < 0 || r > n) return 0 ;
        long long b = (fact[r] * fact[n-r]) % mod ;
        return (fact[n] * findPower(b, mod-2)) % mod ;
    }
    void findSets(int m, vector<int>& count, vector<vector<int>>& t) {
        if(t[m][1]) return ;
        t[m][1] = 1 ;
        count[1]++ ;
        for(int div = 2; div <= m; div++) {
            if(m % div == 0) {
                findSets(m/div, count, t) ;
                for(int len = 1; len < 15; len++) {
                    if(t[m/div][len]) {
                        t[m][len+1] += t[m/div][len] ;
                        count[len+1] += t[m/div][len] ;
                    }
                }
            }
        }
    }
    int idealArrays(int n, int maxVal) {
        vector<vector<int>> t(maxVal+1, vector<int>(15, 0)) ;
        vector<int> count(15, 0) ;
        for(int i = 1; i <= maxVal; i++) {
            findSets(i, count, t) ;
        }
        vector<long long> fact(n+1, 1) ;
        for(int i = 2; i <= n; i++) {
            fact[i] = (fact[i-1] * i) % mod ;
        }
        long long res = 0 ;
        for(int len = 1; len < min(15, n+1); len++) {
            if(count[len]) {
                long long poss = modularnCr(n-1, len-1, fact) ;
                res = (res + (count[len] * poss) % mod) % mod ;
            }
        }
        return res ;
    }
};
