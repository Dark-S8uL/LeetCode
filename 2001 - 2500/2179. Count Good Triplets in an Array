class Solution {
public:
    void update(int i, int l, int r, int idx, vector<long long>& v) {
        if(l == r) {
            v[i] = 1 ;
            return ;
        }
        int mid = l + (r-l) / 2 ;
        if(idx <= mid) update(2*i+1, l, mid, idx, v) ;
        else update(2*i+2, mid+1, r, idx, v) ;
        v[i] = v[2*i+1] + v[2*i+2] ;
    }
    long long query(int st, int end, int i, int l, int r, vector<long long>& v) {
        if(r < st || l > end) return 0 ;
        if(l >= st && r <= end) return v[i] ;
        int mid = l + (r-l) / 2 ;
        int left = query(st, end, 2*i+1, l, mid, v) ;
        int right = query(st, end, 2*i+2, mid+1, r, v) ;
        return left + right ;
    }
    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size() ;
        unordered_map<int, int> mp ;
        for(int i = 0; i < n; i++) mp[nums2[i]] = i ;
        vector<long long> v(4*n, 0) ;
        long long cnt = 0 ;
        update(0, 0, n-1, mp[nums1[0]], v) ;
        for(int i = 1; i < n-1; i++) {
            int idx = mp[nums1[i]] ;
            long long leftCommCnt = query(0, idx, 0, 0, n-1, v) ;
            long long leftUnCommCnt = i - leftCommCnt ;
            long long rightCnt = (n-1) - idx ;
            long long rightCommCnt = rightCnt - leftUnCommCnt ;
            cnt += (leftCommCnt * rightCommCnt) ;
            update(0, 0, n-1, idx, v) ;
        }
        return cnt ;
    }
};
